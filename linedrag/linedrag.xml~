<?xml version="1.0" encoding="UTF-8"?>


<Scene base_name="linedrag" name_space="Scene" name_suffix="0" persistency="666"><Objects><Object base_name="Root" name_space="__global__" name_suffix="0" persistency="666" pickable="0" type="Object" visible="1"><Object ambient="0.3 0.3 0.3 1" base_name="light" beacon="Headlight_beacon" diffuse="1 1 1 1" lightType="point" name_space="__global__" name_suffix="0" on="1" persistency="666" pickable="0" shadow="0" shadowColor="0.1 0.1 0.1 1" shadowMapRes="2048" specular="0.1 0.1 0.1 1" type="Light" visible="1"><Object accept_root="1" aspect="1" at="0 0 1" at_dir="0" base_name="Default" far="512" fov="1.0472" from="5.69698 4.41176 0.101096" name_space="__global__" name_suffix="0" near="0.1" orthoSize="100" persistency="666" pickable="0" scale="1 1 1" type="Camera" up="0 1 0" visible="1"><Object at="0 0 -1" at_dir="0" base_name="Headlight_beacon" from="0 0 0" light="light" name_space="__global__" name_suffix="0" persistency="666" pickable="0" scale="1 1 1" type="LightBeacon" up="0 1 0" visible="1"><constraint active="1" cR="0 1 0" cR_local="0" cR_mode="0" cT="0 1 0" cT_local="0" cT_mode="0" persistency="666"/></Object><constraint active="1" cR="0 1 0" cR_local="0" cR_mode="0" cT="0 1 0" cT_local="0" cT_mode="0" persistency="666"/></Object><Object at="0 0 -1" at_dir="0" base_name="TMP_GEO_SETUP_NAME" from="0 0 0" name_space="__global__" name_suffix="0" persistency="666" pickable="0" scale="1 1 1" sourceparam="" sourcetype="0" type="Geometry" up="0 1 0" visible="1"><constraint active="1" cR="0 1 0" cR_local="0" cR_mode="0" cT="0 1 0" cT_local="0" cT_mode="0" persistency="666"/></Object><Object at="9.64428 -2.08119 -7.44131" at_dir="0" base_name="TMP_GEO_SETUP_NAME" from="9.01397 -2.27205 -6.68878" name_space="__global__" name_suffix="1" persistency="666" pickable="1" scale="5 5 5" sourceparam="" sourcetype="0" type="Geometry" up="-0.421161 0.898341 -0.124927" visible="1"><Object at="0 0 -1" at_dir="0" base_name="Rigged Hand_dae.dae" from="0 0 0" name_space="__global__" name_suffix="0" persistency="666" pickable="0" scale="1 1 1" type="Transform" up="0 1 0" visible="1"><Object base_name="Scene" name_space="__global__" name_suffix="0" persistency="666" pickable="0" type="Object" visible="1"><Object base_name="OpenSG_AmbientLight" name_space="__global__" name_suffix="0" persistency="666" pickable="0" type="ChunkOverrideGroup" visible="1"><Object base_name="Point" name_space="__global__" name_suffix="1" persistency="666" pickable="0" type="PointLight" visible="1"><Object at="0 0.0245625 -1" at_dir="0" base_name="Armature" from="0 0.0245625 0" name_space="__global__" name_suffix="0" persistency="666" pickable="0" scale="1 1 1" type="Transform" up="0 1 0" visible="1"><constraint active="1" cR="0 1 0" cR_local="0" cR_mode="0" cT="0 1 0" cT_local="0" cT_mode="0" persistency="666"/></Object><Object at="0 0 -1" at_dir="0" base_name="Cube_005" from="0 0 0" name_space="__global__" name_suffix="0" persistency="666" pickable="0" scale="1 1 1" type="Transform" up="0 1 0" visible="1"><Object base_name="Armature" name_space="__global__" name_suffix="2" persistency="666" pickable="0" type="Object" visible="1"><Object base_name="Armature" name_space="__global__" name_suffix="1" persistency="666" pickable="0" type="SkinnedGeometry" visible="1"/></Object><constraint active="1" cR="0 1 0" cR_local="0" cR_mode="0" cT="0 1 0" cT_local="0" cT_mode="0" persistency="666"/></Object><Object at="0 0 -1" at_dir="0" base_name="Cube_000" from="0 0 0" name_space="__global__" name_suffix="0" persistency="666" pickable="0" scale="1 1 1" type="Transform" up="0 1 0" visible="1"><Object base_name="Armature" name_space="__global__" name_suffix="4" persistency="666" pickable="0" type="Object" visible="1"><Object base_name="Armature" name_space="__global__" name_suffix="3" persistency="666" pickable="0" type="SkinnedGeometry" visible="1"/></Object><constraint active="1" cR="0 1 0" cR_local="0" cR_mode="0" cT="0 1 0" cT_local="0" cT_mode="0" persistency="666"/></Object><Object at="0.33982 0.278983 1.94723" at_dir="0" base_name="Hemi" from="0.495596 0.785061 2.79554" name_space="__global__" name_suffix="0" persistency="666" pickable="0" scale="1 1 1" type="Transform" up="-0.030777 0.860857 -0.507916" visible="1"><constraint active="1" cR="0 1 0" cR_local="0" cR_mode="0" cT="0 1 0" cT_local="0" cT_mode="0" persistency="666"/></Object><Object at="0.0827517 0.57086 -0.209598" at_dir="0" base_name="Point" from="0.0827517 0.57086 0.790402" name_space="__global__" name_suffix="0" persistency="666" pickable="0" scale="1 1 1" type="Transform" up="0 1 0" visible="1"><constraint active="1" cR="0 1 0" cR_local="0" cR_mode="0" cT="0 1 0" cT_local="0" cT_mode="0" persistency="666"/></Object></Object></Object></Object><constraint active="1" cR="0 1 0" cR_local="0" cR_mode="0" cT="0 1 0" cT_local="0" cT_mode="0" persistency="666"/></Object><constraint active="1" cR="0 1 0" cR_local="0" cR_mode="0" cT="0 1 0" cT_local="0" cT_mode="0" persistency="666"/></Object></Object><Object base_name="None" name_space="__global__" name_suffix="5" persistency="666" pickable="0" type="Object" visible="1"/></Object></Objects><Rendering deferred_rendering="0" frustum_culling="1" fxaa="0" hmdd="0" marker="0" occlusion_culling="0" persistency="666" ssao="0" ssao_kernel="4" ssao_noise="4" ssao_radius="0.02" two_sided="1"/><Scripts persistency="666"><Script base_name="ControlHandle" group="no group" name_space="__script__" name_suffix="0" persistency="666" server="server1" type="Python"><core>
	import VR
	
	VR.controlHandle = VR.Geometry("controlHandle")
	VR.controlHandle.setPrimitive("Sphere .1")
	VR.controlHandle.setPickable(1)
	VR.controlHandle.setFrom([0,0,0])
	VR.scene.addChild(VR.controlHandle)
	
	# Method to properly get center position coordinates of the
	# handle sphere, as getAt() does not return the sphere center.
	def getControlHandleCenter():
		return VR.controlHandle.getWorldFrom()
		#chandle = VR.controlHandle.getAt()
		#return [chandle[0], chandle[1], chandle[2] + 1]
		
	VR.getControlHandleCenter = getControlHandleCenter
</core></Script><Script base_name="Hand" group="no group" name_space="__script__" name_suffix="0" persistency="666" server="server1" type="Python"><core>
	import VR
	
	#hand = VR.loadGeometry('/home/administrator/Desktop/RiggedHand_dae.dae')
	hand = VR.loadGeometry('hand.dae')
	#hand = VR.loadGeometry('/home/administrator/Projects/Cyberglove/usecases/linedrag/RiggedHand_dae.dae', preset = 'COLLADA')
	hand.setWorldFrom([15,5,-5])
	hand.setWorldUp([1,0,0])
	hand.translate([-6, -7, 0])
	hand.setPickable(True)
	hand.setPersistency(3)
	hand.setScale(9,9,9)
	hand.setVisible(False)

	VR.scene.addChild(hand)
	VR.hand = hand
	
	
</core></Script><Script base_name="Labels" group="no group" name_space="__script__" name_suffix="0" persistency="666" server="server1" type="Python"><core>
	import VR
	
	plane = VR.Geometry()
	plane.setPrimitive("Plane 3 3 1 1")
	
	plane.setColor("white")
	
	sprite = VR.Sprite()
	sprite.setText("Welcome to Linedrag.")
	sprite.setSize(2,0.2)

	cam = VR.find("Default")
	textpos = [
		cam.getWorldFrom()[0] + 3 * cam.getWorldDir()[0],
		cam.getWorldFrom()[1] + 3 * cam.getWorldDir()[1],
		cam.getWorldFrom()[2] + 3 * cam.getWorldDir()[2],
	]
	
	plane.setFrom(textpos)
	plane.setAt([0,0,1])
	sprite.setAt(plane.getAt())
	sprite.setFrom([plane.getFrom()[0], plane.getFrom()[1], plane.getFrom()[2]])
	sprite.setUp(VR.find("Default").getUp())
	
	VR.scene.addChild(plane)
	VR.scene.addChild(sprite)
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
</core></Script><Script base_name="Line" group="no group" name_space="__script__" name_suffix="0" persistency="666" server="server1" type="Python"><core>
	import VR
	
	lineHandles = [
		#[0, 0, 0],
		#[2, 0, 0],
		#[2, 0, 2],
		#[4, 0, 2],
		#[5, 0, 3],
		#[5, 0, 4],
		#[7, 0, 4],
		#[8, 0, 5],
		#[8, 0, 6.5],
		[1,0,1],
		[1.2, 0, .8],
		[1.2, 0, .8],
		[1.2, 0, .6],
		[1.0, 0, .5],
		[1.1, 0, .3],
		[1.3, 0, .3],
		[1.5, 0, .4],
		[1.5, 0, .6],
		[1.5, 0, .8],
		[1.3, 0, .9],
		[1.2, 0, 1.1],
		[1.3, 0, 1.3],
		[1.5, 0, 1.4],
		[1.7, 0, 1.3],
		[1.9, 0, 1.2],
		[2.1, 0, 1.3],
		[2.0, 0, 1.5],
		[1.9, 0, 1.7],
		[1.7, 0, 1.8],
		[1.5, 0, 1.7],
		[1.3, 0, 1.5],
		[1.1, 0, 1.4],
		[.9, 0, 1.4],		
		[.7, 0, 1.5],
		[.7, 0, 1.1],
		[.8, 0, .5],
		[.7, 0, .4],
		[.5, 0, .4],
		[.5, 0, .3],
		[.4, 0, .2],
		[.2, 0, .2],
		[.2, 0, .0],
		[.0, 0, .0]
	]
	
	lineCount = (len(lineHandles) / 2)
	
	VR.ptool = VR.Pathtool()
	VR.paths = [None] * lineCount
	
	for i,N in enumerate(VR.paths):	
		VR.paths[i] = VR.ptool.newPath(None, VR.scene)
		VR.ptool.extrude(None, VR.paths[i])
		VR.ptool.setVisuals(False, True)
		handles = VR.ptool.getHandles(VR.paths[i])
		handles[0].setFrom(lineHandles[i*2 + 0])
		handles[1].setFrom(lineHandles[i*2 + 1])
		if i != lineCount - 1:
			handles[2].setFrom(lineHandles[i*2 + 2])
	VR.ptool.update()
	
	# Print debugging circles on the line.
	for linePath in VR.paths:
		VR.testCircles(linePath.getPositions())		
</core></Script><Script base_name="Plane" group="no group" name_space="__script__" name_suffix="0" persistency="666" server="server1" type="Python"><core>
	import VR
	
	planes = [
		{  
			"x":.9, 
			"y": 0, 
			"z": 1.4,
			"angle": 5,
			"config": [ 
				{
					"key1": 0,
					"key2": 1,
					"key3": 0,
					"key4": 0,
					"slider1": False,
					"slider2": 0,
					"slider3": 0,
					"slider4": 0,
					"sliderX": 0,
					"sliderY": 0
				},
				{
					"key1": 0,
					"key2": 0,
					"key3": 0,
					"key4": 1,
					"slider1": False,
					"slider2": 0,
					"slider3": 0,
					"slider4": 0,
					"sliderX": 0,
					"sliderY": 0
				},
				{
					"key1": 1,
					"key2": 1,
					"key3": 0,
					"key4": 0,
					"slider1": False,
					"slider2": 0,
					"slider3": 0,
					"slider4": 0,
					"sliderX": 0,
					"sliderY": 0
				}
			]
		},
		{  
			"x": 2.1, 
			"y": 0, 
			"z": 1.3, 
			"angle": 5,
			"config": [ 
				{
					"key1": 0,
					"key2": 1,
					"key3": 0,
					"key4": 0,
					"slider1": False,
					"slider2": 0,
					"slider3": 0,
					"slider4": 0,
					"sliderX": 0,
					"sliderY": 0
				},
				{
					"key1": 0,
					"key2": 0,
					"key3": 0,
					"key4": 1,
					"slider1": False,
					"slider2": 0,
					"slider3": 0,
					"slider4": 0,
					"sliderX": 0,
					"sliderY": 0
				},
				{
					"key1": 1,
					"key2": 1,
					"key3": 0,
					"key4": 0,
					"slider1": False,
					"slider2": 0,
					"slider3": 0,
					"slider4": 0,
					"sliderX": 0,
					"sliderY": 0
				}
			]
		},
		{  
			"x": .8, 
			"y": 0, 
			"z": .5, 
			"angle": 5,
			"config": [ 
				{
					"key1": 0,
					"key2": 1,
					"key3": 0,
					"key4": 0,
					"slider1": False,
					"slider2": 0,
					"slider3": 0,
					"slider4": 0,
					"sliderX": 0,
					"sliderY": 0
				},
				{
					"key1": 0,
					"key2": 0,
					"key3": 0,
					"key4": 1,
					"slider1": False,
					"slider2": 0,
					"slider3": 0,
					"slider4": 0,
					"sliderX": 0,
					"sliderY": 0
				},
				{
					"key1": 1,
					"key2": 1,
					"key3": 0,
					"key4": 0,
					"slider1": False,
					"slider2": 0,
					"slider3": 0,
					"slider4": 0,
					"sliderX": 0,
					"sliderY": 0
				}
			]
		}
	]
	
	VR.planes = []
	VR.challenges = []
	
	for plane in planes:
		planeGeo = VR.Geometry("plane" + str(plane["x"]) + str(plane["y"]) + str(plane["z"]))
		planeGeo.setPrimitive("Plane .1 .1 12")
		planeGeo.setFrom([plane["x"], plane["y"], plane["z"]])
		planeGeo.setColor("blue")
		#planeGeo.setPose(5, 5, 5) #pos, dir, up
		#def getPlaneCenter(): return [plane["x"], plane["y"], plane["z"]]
		#planeGeo.getPlaneCenter = getPlaneCenter
		VR.scene.addChild(planeGeo)	

		VR.challenges.append({
			"done": False,
			"plane": planeGeo,
			"configuration": plane["config"]
		})
	
	
	
	
#	def planeIntersection():
#		return VR.getIntersected()
#		
#	VR.planeIntersection = planeIntersection
</core></Script><Script base_name="ShowTime" group="no group" name_space="__script__" name_suffix="0" persistency="666" server="server1" type="Python"><core>
	import VR
	
	print VR.timeCounter
	
	if not VR.touchedHandle:
		return
		
	if not hasattr(VR, 'spriteTime'):
		VR.spriteTime = VR.Sprite()
		VR.spriteTime.setSize(10,1)
		VR.scene.addChild(spriteTime)
		plane = VR.Geometry()
		plane.setPrimitive("Plane 0.5 0 1 1")
		plane.setVisible(False)
		VR.scene.addChild(plane)
		
	VR.timeCounter += 50
	
	VR.spriteTime.setText(str(VR.timeCounter / 1000.0) + " seconds")
	cam = VR.find("Default")
	textpos = [
		cam.getWorldFrom()[0] + 10 * cam.getWorldDir()[0]-1,
		cam.getWorldFrom()[1] + 10 * cam.getWorldDir()[1],
		cam.getWorldFrom()[2] + 10 * cam.getWorldDir()[2]+5,
	]
	
	plane.setFrom(textpos)
	plane.setAt([0,0,1])
	VR.spriteTime.setAt([0,0,1])
	#sprite.setFrom([textpos[0],textpos[1]+7, textpos[2]])
	VR.spriteTime.setFrom(plane.getFrom())
	#sprite.setUp(VR.find("Default").getUp())
	
	
	
	
	
	
	
	

	
	
</core></Script><Script base_name="TESTING" group="no group" name_space="__script__" name_suffix="0" persistency="666" server="server1" type="Python"><core>
	import VR
	
	#for challenge in VR.challenges:
	#	challenge["done"] = False
	#	challenge["plane"].setColor("blue")
	
	annotation = VR.AnnotationEngine()
	#annotation.setBackground([1, 1, 1, 1])
	#annotation.setColor([0, 0, 0, 1])
	#annotation.setSize(100)
	
	plane = VR.Geometry()
	plane.setPrimitive("Plane 3 3 1 1")
	VR.scene.addChild(plane)
	
	#plane.setFrom([0,2,0])
	#plane.setAt([0,0,1])
	plane.setColor("white")
	
	sprite = VR.Sprite()
	sprite.setText("test tet sdasldldl")
	sprite.setSize(1,0.1)

	#sprite.setLabel("test text", 1.0)
	VR.scene.addChild(sprite)
	cam = VR.find("Default")
	textpos = [
		cam.getWorldFrom()[0] + 3 * cam.getWorldDir()[0],
		cam.getWorldFrom()[1] + 3 * cam.getWorldDir()[1],
		cam.getWorldFrom()[2] + 3 * cam.getWorldDir()[2],
	]
	an = annotation.set(0, textpos ,"Test text blaaaaaaaaaaaaaaaaaaaaaaaadddddddddddddddddddddddfaaaaaaaaaaaaaa")
	plane.setFrom(textpos)
	plane.setAt([0,0,1])
	sprite.setFrom([plane.getFrom()[0], plane.getFrom()[1], plane.getFrom()[2]-0.01])
	sprite.setAt(plane.getAt())
	
	print an
	annotation.setFrom(textpos)
	#annotation.setScreensize(True)
	#annotation.setVisible(True)
	#VR.scene.addChild(annotation)
	
	
	
	
	
	
	
	
	
	
	
	
	
	
</core></Script><Script base_name="challenge" group="gamelogic" name_space="__script__" name_suffix="0" persistency="666" server="server1" type="Python"><core>
	import VR
	import time
	from random import randint
	import sys


	#VR.hand.setVisible(True)
	
	configuration = {}
	
	configuration["key1"] = 1
	configuration["key2"] = 1
	configuration["key3"] = 0
	configuration["key4"] = 0
	configuration["slider1"] = False
	configuration["slider2"] = 0
	configuration["slider3"] = 0
	configuration["slider4"] = 0
	configuration["sliderX"] = 0
	configuration["sliderY"] = 0
	
	#configuration = [0] * 10
	givenConfig = [
		configuration["key1"], 
		configuration["key2"], 
		configuration["key3"],
		configuration["key4"], 
		configuration["slider1"], 
		configuration["slider2"], 
		configuration["slider3"], 
		configuration["slider4"], 
		configuration["sliderX"],
		configuration["sliderY"]
	]
	
	print "time" + str(time.time())

  

	#VR.hand.setVisible(True)
	VR.isChallenge = False
	
	
</core></Script><Script base_name="checkControlHandle" group="gamelogic" name_space="__script__" name_suffix="0" persistency="666" server="server1" type="Python"><core>
	import VR
	import math
	
	if not hasattr(VR, 'hasInitialized'): return
	
	if not VR.controlHandle.getFrom() == [0,0,0]:
		VR.touchedHandle = True
	
	def euclideanDistance(vec1, vec2, dimension=3):
		sum = 0
		for i in range(0, dimension):
			sum += math.pow(vec1[i] - vec2[i], 2)
		return math.sqrt(sum)
	
	VR.euclideanDistance = euclideanDistance
	
	# Bring handle into line plane
	#pos = VR.controlHandle.getWorldFrom()
	#VR.controlHandle.setWorldFrom(pos[0], 0, pos[2])
	
	# Position of handle (draggable sphere).
	chandle = VR.getControlHandleCenter()
	
	# After the for loop, this will contain the 
	# minimal distance between line and handle.
	minDist = 10000
	
	# Maximum distance between handle and line for 
	# for the handle to touch the line.
	eps = .1
	
	for linePath in VR.paths:
		for idx, node in enumerate(linePath.getPositions()):
			dist = euclideanDistance(node, chandle)
			minDist = dist if dist < minDist else minDist
		
	# Set handle color to green if touching the line, 
	# red otherwise.
	if (minDist < eps and not VR.isChallenge):
		VR.controlHandle.setColor("green")
		
	elif not VR.isChallenge:
		if (VR.counter == 0):
			#VR.controlHandle.setColor("yellow")
			print "looser"
			VR.counter = 100
		else:
			VR.controlHandle.setColor("red")
			VR.counter = VR.counter - 1
	else:
		# When challenge is running, change the handles color according to the
		# remaining time
		m = VR.Material('challengeMaterial')
		m.setDiffuse([
			(VR.timeInChallenge / (VR.maxChallengeTime * 1.0)),
			(1 - VR.timeInChallenge / (VR.maxChallengeTime * 1.0)),
			0
		])
		VR.controlHandle.setMaterial(m)
	
	oldPos = VR.controlHandle.getWorldFrom()
	VR.controlHandle.setWorldFrom([oldPos[0], 0, oldPos[2]])
</core><trig type="on_timeout" dev="" state="Pressed" param="10" key="0" base_name="trigger" name_space="__global__" name_suffix="0" persistency="666"/></Script><Script base_name="checkPlane" group="gamelogic" name_space="__script__" name_suffix="0" persistency="666" server="server1" type="Python"><core>
	import VR
	import time
	from random import randint
	import sys
	
	
	
	if not hasattr(VR, 'hasInitialized'): return
	
	def wait_until(checkHand, configuration, timeout = randint(5,10), period=0.1):
	  mustend = time.time() + timeout
	  while time.time() < mustend:
		print str(time.time()) + ", " + str(mustend)
		if checkHand(configuration): 
			VR.plane.setColor("green")
			print "you won!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
			VR.hasWon = True
			return True
		print "waiting"
		time.sleep(period)
	  print "nothing found"
	  VR.plane.setColor("red")
	  return False
	  
  	def checkHand(configuration): 
  		#if not hasattr(configuration, "key1"): return False
  	
		if configuration["key1"] and configuration["key1"] != getConfiguration(glove)[0]:
			return False
		if configuration["key2"] and configuration["key2"] != getConfiguration(glove)[1]:
			return False
		if configuration["key3"] and configuration["key3"] != getConfiguration(glove)[2]:
			return False
		if configuration["key4"] and configuration["key4"] != getConfiguration(glove)[3]:
			return False
		if configuration["slider1"] and configuration["slider1"] != getConfiguration(glove)[4]:
			return False
		if configuration["slider2"] and configuration["slider2"] != getConfiguration(glove)[5]:
			return False
		if configuration["slider3"] and configuration["slider3"] != getConfiguration(glove)[6]:
			return False
		if configuration["slider4"] and configuration["slider4"] != getConfiguration(glove)[7]:
			return False
		if configuration["sliderX"] and configuration["sliderX"] != getConfiguration(glove)[8]:
			return False
		if configuration["sliderY"] and configuration["sliderY"] != getConfiguration(glove)[9]:
			return False
		print True
		return True
		
	def getConfiguration(glove):
		#if not hasattr(glove, 'getKeyState'): return {}
	
		obj = {}
		obj["key1"] = glove.getKeyState(key1)
		obj["key2"] = glove.getKeyState(key2)
		obj["key3"] = glove.getKeyState(key3)
		obj["key4"] = glove.getKeyState(key4)
		
		obj["slider1"] = glove.getSlider(slider1)
		obj["slider2"] = glove.getSlider(slider2)
		obj["slider3"] = glove.getSlider(slider3)
		obj["slider4"] = glove.getSlider(slider4)
			
		obj["sliderX"] = glove.getSlider(sliderX)
		obj["sliderY"] = glove.getSlider(sliderY)
		config = [obj["key1"], obj["key2"], obj["key3"], obj["key4"], obj["slider1"],
					obj["slider2"], obj["slider3"], obj["slider4"]]
		#return [0] * 10
		return config
	
	#if VR.hasWon: # or VR.isChallenge:
	#	return
	
	epsilon = .15
	
	glove = VR.find('vrpn_device')
	
	
	key1 = 0 #index finger
	key2 = 1 #middle finger
	key3 = 2 #ring finger
	key4 = 3 #little finger
	
	slider1 = 100 #index finger
	slider2 = 200 #middle finger
	slider3 = 300 #ring finger
	slider4 = 400 #small finger
	
	sliderX = 104 #cursor x direction
	sliderY = 105 #cursor y direction
	
	print getConfiguration(glove)		

	for challenge in VR.challenges:
		if challenge["done"]:
			continue
		#print VR.timeInChallenge
	
		posHandle = VR.getControlHandleCenter()
		posPlane = challenge["plane"].getWorldFrom()
	
		distance = VR.euclideanDistance(posHandle, posPlane)
	
		if (distance < epsilon) and (not VR.isChallenge):
			# First iteration, starting challenge
			VR.isChallenge = True
			VR.timeInChallenge = 0
			print "plane"
			VR.controlHandle.setColor("black")
			VR.controlHandle.setPickable(-1)
			VR.challengePos = VR.controlHandle.getAt()
			
			# Show hand
			cam = VR.find("Default")
			handpos = [
				cam.getWorldFrom()[0] + 6 * cam.getWorldDir()[0],
				cam.getWorldFrom()[1] + 6 * cam.getWorldDir()[1],
				cam.getWorldFrom()[2] + 6 * cam.getWorldDir()[2],
			]
			VR.hand.setVisible(True)
			VR.hand.setFrom(handpos)
			VR.hand.setAt(cam.getWorldFrom())
	
			#VR.find('Default').setAt(posPlane)
			
		elif distance < epsilon and VR.isChallenge:
			# challenge is already started, check
			VR.timeInChallenge += 20
			VR.controlHandle.setAt(VR.challengePos)
			
			print VR.challengePart
			print "of"
			print len(challenge["configuration"])
			
			if VR.timeInChallenge > VR.maxChallengeTime:
				challenge["plane"].setColor("red")
				print "you suck"
				challenge["done"] = True
				VR.isChallenge = False
				VR.controlHandle.setPickable(1)
				VR.hand.setVisible(False)
				return True
			
			
			#elif VR.challengePart < len(challenge["configuration"] and checkHand(challenge["configuration"][VR.challengePart]): 
			elif checkHand(challenge["configuration"][VR.challengePart]): 
				VR.challengePart += 1
				if VR.challengePart >= len(challenge["configuration"]):
					# challenge won, no more challenge part available
					VR.challengePart = 0
					challenge["plane"].setColor("green")
					print "you won!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
					challenge["done"] = True
					VR.isChallenge = False
					VR.hasWon = True
					VR.controlHandle.setPickable(1)
					VR.hand.setVisible(False)
					return True
				else:
					# challenge won, more parts to come
					VR.timeInChallenge = 0
					print "next challenge"
					# TODO next hand
					
					
			
		#else:
		#	VR.isChallenge = False
		
		

	
	#wait_until(checkHand, 5)
</core><trig type="on_timeout" dev="" state="Pressed" param="20000" key="0" base_name="trigger" name_space="__global__" name_suffix="0" persistency="666"/></Script><Script base_name="controlHandleDrag" group="gamelogic" name_space="__script__" name_suffix="0" persistency="666" server="server1" type="Python"><core>
	import VR
	
	if not hasattr(VR, 'hasInitialized'): return
		
	glove = VR.find('vrpn_device')
	
	b = VR.find('ART_tracker.1')
	glove.setBeacon(b)
	b.findAll('av_ray')[0].show()	
	
	#for i in range(0, 255):
	#	key = glove.getKeyState(i)
	#	if key != -1:
	#		print "" + str(i) + " is " + str(key)
	
	def startDrag():
		if glove.intersect(VR.getRoot()):
			VR.isDragging = True
			print "Attempting to start dragging, found intersecting object(s)."
			obj = glove.getIntersected()
			print "Intersecting Object:" + str(obj)
			glove.drag(obj)
		else:
			print "Attempting to start dragging, but no intersecting object."
		
	def stopDrag():
		VR.isDragging = False
		glove.drop()
		
	#print glove.getSlider(100)
		
	
	if hasattr(glove, 'getSlider') and hasattr(glove, 'setBeacon'):
		num = glove.getSlider(100) # bend sensor data
		glove.setBeacon(VR.find('ART_tracker.1'))
	else:
		num = 0	
	
	
	# If gripping while not dragging the handle, start dragging it.
	if num >= 20 and not VR.isDragging:
		VR.fGlove = 0
		VR.touchedHandle = True
		startDrag()
		
	# If loosening the grip while dragging the handle, stop dragging it.
	# Also stio dragging if a challenge is running
	if (num < 20 and VR.isDragging) or VR.isChallenge:
		VR.fGlove = 1
		stopDrag()
		
	
	# OLD METHOD
	#def drag():	
	#	if glove.intersect(VR.getRoot()):
	#		print "in"
	#		obj = glove.getIntersected()
	#		#key = dev.getKey()
	#		#state = dev.getState()
	#		print 'drag', obj.getName()
	#		if not VR.fGlove : 
	#			glove.drag(obj)
	#			print "drag"
	#		else: glove.drop()

</core><trig type="on_timeout" dev="" state="Pressed" param="20000" key="0" base_name="trigger" name_space="__global__" name_suffix="0" persistency="666"/></Script><Script base_name="debugging" group="no group" name_space="__script__" name_suffix="0" persistency="666" server="server1" type="Python"><core>
	import VR
	
	# Create small debugging spheres on all coordinates stored in the
	# array nodes. nodes has to be an array of three dimensional arrays,
	# each containing the coordinates of the spheres.
	# The spheres will be created as children of VR.scene
	def testCircles(nodes):
		for idx, node in enumerate(nodes):
			circ = VR.Geometry("debug" + str(node[0])+str(node[1])+str(node[2]))
			circ.setPrimitive("Sphere 0.01")
			circ.setFrom(node)
			VR.scene.addChild(circ)
	VR.testCircles = testCircles
</core></Script><Script base_name="init" group="no group" name_space="__script__" name_suffix="0" persistency="666" server="server1" type="Python"><core>
	import VR
	import os
	#Only activate following line if real or virtual glove available!!
	#os.system("cd /home/glovevm/Rechner/Rechner/build && ./server")
	#if hasattr(VR, 'scene') 
	vrpnd = VR.find("vrpn_device")
		
	if hasattr(VR, 'scene') and VR.scene: VR.scene.destroy()
	VR.scene = VR.Object('scene')
	VR.getRoot().find('light').addChild(VR.scene)
	VR.counter = 100;
	#VR.find('Default').setFrom([0,3,1])
	#VR.find("Default").setAt([0,0,1])
	
	VR.dots = VR.Object('debugcircles')
	VR.scene.addChild(VR.dots)
	VR.touchedHandle = False
	VR.timeCounter = 0
	VR.isDragging = False
	
	VR.isChallenge = False
	VR.timeInChallenge = 0
	VR.challengePos = []
	VR.challengePart = 0
	
	VR.maxChallengeTime = 2000
	VR.hasWon = False
	
	# Create game objects
	VR.triggerScript("debugging")
	VR.triggerScript("Line")
	VR.triggerScript("ControlHandle")
	VR.triggerScript("Plane")
	VR.triggerScript("Hand")
	
	# Debugging spheres for line
	#VR.testCircles([getControlHandleCenter()])

	VR.hasInitialized = True
	print 'done init'
	
	
	#print(vrpnd)
	
	#digi1 = vrpnd.getKeyState(3)
	#digi2 = vrpnd.getKeyState(2)
	
	#if digi1 == 1:
	#	print ("digi1")
	#if digi2 == 1:
	#	print ("digi2")
</core><trig type="on_scene_load" dev="" state="Pressed" param="" key="0" base_name="trigger" name_space="__global__" name_suffix="0" persistency="666"/></Script><Script base_name="moveCam" group="no group" name_space="__script__" name_suffix="0" persistency="666" server="server1" type="Python"><core>
	import VR
	
	cam = VR.find('Default')
	cam.translate([0,1,0])
</core></Script><Script base_name="setPlaneDirections" group="gamelogic" name_space="__script__" name_suffix="0" persistency="666" server="server1" type="Python"><core>
	import VR
	
	for challenge in VR.challenges:
		plane = challenge["plane"]
		
		# Make plane look at cam
		plane.setAt(VR.find("Default").getWorldFrom())	
		
		# (Alternative) Make plane look at control handle	
		#plane.setAt(VR.controlHandle.getWorldFrom())
</core><trig type="on_timeout" dev="" state="Pressed" param="50" key="0" base_name="trigger" name_space="__global__" name_suffix="13" persistency="666"/></Script></Scripts><Sockets persistency="666"/><Background color="0.6 0.6 0.6" format=".png" path="" persistency="666" type="0"/><Navigation active="Orbit" persistency="666"/><Materials persistency="666"/><Semantics persistency="666"/></Scene>
