\section{Software}

\subsection{Arduino platform and server code}
\label{arduinoandserver}

Most of the hardware related programming code was implemented by the team from last semester, we have left much of it unchanged. The team has implemented the platform code for the Arduino controller, the server application which runs on the cave computer and forwards the TCP packages from the arduino to PolyVR via the VRPN protocol.

We have slightly modified the Arduino code to adapt the hardware changes that we have made to the new glove. The new bending sensors are being tracked and their data is properly being sent in the way the previous team has designed. The sensor data is collected on the Arduino and mapped into a TCP package, which contains the state of all sensors at a certain point in time. Those TCP packages are then being sent repeatedly as long as the glove runs.

The TCP packages are constructed as an eleven character long string, where each sensor information is encoded as one character. Boolean sensor values are just encoded as 0 (zero) or 1 (one), all other floating sensor values are just cast into characters. The packages have the following form:

\label{tcppackageform}
\begin{description}
	\item[Character 0] Touch sensor: Thumb, index finger
	\item[Character 1] Touch sensor: Thumb, middle finger
	\item[Character 2] Touch sensor: Thumb, ring finder
	\item[Character 3] Touch sensor: Thumb, little finger
	\item[Character 4] Virtual button
	\item[Character 5] Bending sensor: Index finger
	\item[Character 6] Bending sensor: Middle finger
	\item[Character 7] Bending sensor: Ring finger
	\item[Character 8] Bending sensor: Little finger
	\item[Character 9] Joystick in x-direction
	\item[Character 10] Joystick in y-direction
\end{description}

On the computer which runs the PolyVR application (which usually is the cave computer), the server application has to run to receive those TCP packages and forward them to PolyVR. PolyVR uses VRPN, a protocol designed for communication between virtual reality devices, to receive input data. The initial idea was to make the Arduino code use the VRPN protocol by itself and directly send the data to the VRPN interface of PolyVR. However, has the team from last semester has pointed out in their documentation, VRPN is not available for Arduino, and as we have found out it is nearly impossible to develop a custom VRPN library which works on the Arduino, especially due to the way VRPN works. We have settled for using the server application the way it was designed by the last team, however added code to the use cases which at last automatically runs the server on start up of the use cases.

The touch sensors supply values of $0$ or $1$, corresponding to wether the thouch sensor is pressed or not. The bending sensors supply floating point values which are around zero when not bending the sensor, and go up to around $20$ when bending the finger. We have used $10$ as threshold to determine wether the sensor is bent or not. The joystick unfortunatly does not supply correct values at the moment. We are not sure if this is caused by incorrect wiring, a defect of the joystick or a problem in the arduino software, and could not find the causing of the error. This could be a follow-up for the next team.

In order to make a use case automatically run the server application, the following code has to be added at the beginning of the initialization script. Make sure that the server application has been built sucessfully and the path to the executable is correct.

\begin{lstlisting}[language=python]
os.system("cd ../../Rechner/Rechner/build && ./server")
\end{lstlisting}

\subsection{Emulating the glove}

Because the arduino controller uses a low level TCP connection to send the sensor data to the VRPN server application, we have found that it is very easy to emulate the glove for testing purposes in enviroments outside the cave, where the glove can not be used during developement.

For emulation, the linux tool \texttt{netcat} can be used. It is a command line tool which exposes many features regarding TCP commands. To start emulation, enter the following command into terminal while the server application runs in another terminal window:

\begin{lstlisting}[language=bash]
$ netcat localhost 3490
\end{lstlisting}

This will initiate a TCP connection to the same computer (localhost) on port 3490, which is the port that the server application listens for. Then type \texttt{69} and hit enter. This is a hard coded message that the team from last semester has defined and for which the server application waits to make sure that the talking device really is the arduino application and not a random device which coincidentally also uses port 3490.

Then, strings with a length of exactly 10 can be typed and sent using the enter key, in order to send virtual sensor data to the server application. The sensor data encoded in the strings follow the format defined in section \ref{tcppackageform}.

\subsection{Virtual Machine}

For the developement of the use cases in PolyVR we have set up a virtual machine, so that we could work on the code at home. The virtual machine uses Lubuntu as operating system, a variant of Ubuntu capable of running all required software including PolyVR, but more sleek and smaller in size than Ubuntu. The virtual machine was then exported to a \texttt{.vdi} file so that other people could download and use it.

The fully configured virtual machine is available for download at \url{https://goo.gl/Pg1WCJ}. In Windows, the machine can be run using Oracles VirtualBox (\url{https://www.virtualbox.org/wiki/Downloads}). The login username and password are both \texttt{glovevm}.

The machine comes with a terminal and filebrowser preinstalled by the OS, as well as installations of CodeBlocks, PolyVR, the VRPN library, our project repository and GitKraken for managing the git repository, although we have used mostly terminal commands.

We have also written a seperate documentation for using the virtual machine in German. This document especially explains how to setup Oracles Virtual Box and how to import the \texttt{.vdi} image file. This documentation is available at the GitLab repository under ``documentation/VMDocumentation''.

\subsection{User Manual}
The following sections describe how to download the repository and get started with the use case applications.

\subsubsection{Downloading the repository}

The first step is to download the git repository from gitlab, which can easily be achieved using the \texttt{git clone} command. Then, change into the repositories directory using \texttt{cd}. All following guides assume that the repository is already downloaded and that the user has changed to the directory.

\begin{lstlisting}[language=bash]
$ git clone http://imi-dev.imi.kit.edu:443/vrp1718/Cyberglove.git
$ cd Cyberglove
\end{lstlisting}

\subsubsection{Repository directory structure}

After downloading, the directory should have the following structure.

\dirtree{%
	.1 Cyberglove/.
%
	.2 arduino-software.
	.3 newcode.
	.4 oldcode.
%
	.2 Blender.
%
	.2 documentation.
	.3 assets.
	.3 content.
	.3 VMDocumentation.
%
	.2 Eagle.
%
	.2 server.
	.3 build.
%
	.2 usecases.
	.3 Ball.
	.3 Breakout.
	.3 Hanoi.
	.3 linedrag.
	.3 Maze.
	.3 Memory.
	.3 Menu.
	.3 ObstgegenFastfood.
	.3 skytest.
	.3 WireLoop.
%	%.3 test2 %todo
}

The directory \texttt{arduino-software/} contains the arduino code for the controller. It contains the subdirectories \texttt{oldcode}, which is the unmodified code from last semester, as well as \texttt{newcode}, which contains our modified code that has adapted to the hardware changes. The code files can be modified using the official Arduino IDE. A detailed documentation on the arduino software can be found in section \ref{arduinoandserver}. 

The directory \texttt{Blender/} contains all Blender sketches that we have used during the project, including the hand models used in the linedrag use case and the case models that we have 3D printed.

\texttt{documentation/} contains the source LaTeX files for this document. The \texttt{.tex} files with the sections contents are put inside \texttt{documentation/content}, while \linebreak\texttt{documentation/assets} contains files declaring LaTeX variables and dependencies. The subdirectory \linebreak\texttt{documentation/VMDocumentation} contains an explanation on how to use our virutal machine.

\texttt{Eagle/} contains the circuit board models which can be edited in AutoDesk Eagle.

Under \texttt{server/} the server application can be found. Its functionality is documented in section \ref{arduinoandserver}, a guide on how to use it is in section \ref{howtorunserver}.

\texttt{usecases/} contains all use cases that we have implemented. Each subdirectory includes exactly one use case with its corresponding \texttt{.xml} or \texttt{.pvr} file, which can be opened in PolyVR.

\subsubsection{Setting up and running the server application}
\label{howtorunserver}

When downloaded, the source code for the server application lies in the directory \linebreak \texttt{Cyberglove/server}. Change to this directory and then into its build directory.

Then, run \texttt{cmake ..} and \texttt{make} to build the program and create an executable. This executable will be called \texttt{server} and can then be found inside the \texttt{Cyberglove/server/build} directory. It can be run by calling it by its name.


\begin{lstlisting}[language=bash]
$ cd server/build
$ cmake ..
$ make
$ ./server
\end{lstlisting}

If the Arduino is not running yet, start it now. After the server application started running, press the Arduinos reset button to restart Arduinos program. The Arduino will then connect to the server via WIFI. 

%Important side note: In our use case applications for the Cyberglove you do not need to start the server (\texttt{./server} command) manually. The server will be started automatically by PolyVR.

\subsubsection{Running the use case applications}
For all of the use case applications the user simply has to start the specific application in PolyVR. Then the server will be started automatically. Afterwards the user only has to press the reset button of the microcontroller and a connection with PolyVR will be established. If the reset button is out of reach for the user for example because of the cover of the case the user alternatively can take out the battery pack and put it back in again in order to reset the microcontroller.
For the use case ``Line Drag'' the user has to run the \texttt{init} script manually one more time before the application runs properly. 

%\subsection{Using the glove in new PolyVR applications}
% this is already covered in usecases > glove dragging code










